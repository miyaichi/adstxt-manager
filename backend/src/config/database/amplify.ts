import { DataStore } from '@aws-amplify/datastore';
import { DatabaseRecord, DatabaseQuery, WhereCondition } from './index';
import { createLogger } from '../../utils/logger';

// Import the Amplify models - these would be generated by Amplify CLI
// For example:
import {
  Request,
  Message,
  AdsTxtRecord,
  AdsTxtCache,
  SellersJsonCache,
} from '../../models/amplify-models/index';

const logger = createLogger('AmplifyDatabase');

/**
 * Amplify DataStore adapter for the database interface
 * This implementation uses AWS Amplify DataStore to provide a cloud-synced database
 */
export class AmplifyDatabase {
  private static instance: AmplifyDatabase;

  // Map table names to Amplify model classes
  private modelMap: Record<string, any> = {
    requests: Request,
    messages: Message,
    ads_txt_records: AdsTxtRecord,
    ads_txt_cache: AdsTxtCache,
    sellers_json_cache: SellersJsonCache,
  };

  private constructor() {
    // This is a singleton - initialization code goes here
    logger.info('AmplifyDatabase instance created');
  }

  /**
   * Get the singleton instance of the database
   */
  public static getInstance(): AmplifyDatabase {
    if (!AmplifyDatabase.instance) {
      AmplifyDatabase.instance = new AmplifyDatabase();
    }
    return AmplifyDatabase.instance;
  }

  /**
   * Initialize the database and start DataStore sync
   */
  public async initialize(): Promise<void> {
    try {
      logger.info('Initializing Amplify DataStore');
      await DataStore.start();
      logger.info('Amplify DataStore initialized and ready');
      return Promise.resolve();
    } catch (error) {
      logger.error('Failed to initialize Amplify DataStore', error);
      return Promise.reject(error);
    }
  }

  /**
   * Get the Amplify model class for a table name
   */
  private getModelClass(table: string): any {
    const modelClass = this.modelMap[table];
    if (!modelClass) {
      throw new Error(`Model not found for table: ${table}`);
    }
    return modelClass;
  }

  /**
   * Convert where conditions to Amplify predicates
   */
  private buildPredicates(where: WhereCondition | WhereCondition[]): any {
    if (Array.isArray(where)) {
      // If it's an array, we'll join with AND predicates
      return where.map((condition) => this.buildPredicates(condition));
    }

    const conditions: any[] = [];

    // Process each condition in the where object
    Object.entries(where).forEach(([field, condition]) => {
      if (typeof condition === 'object') {
        // Handle complex conditions (eq, gt, lt, etc.)
        Object.entries(condition).forEach(([operator, value]) => {
          switch (operator) {
            case 'eq':
              conditions.push((c) => c.eq(field, value));
              break;
            case 'ne':
              conditions.push((c) => c.ne(field, value));
              break;
            case 'gt':
              conditions.push((c) => c.gt(field, value));
              break;
            case 'gte':
              conditions.push((c) => c.ge(field, value));
              break;
            case 'lt':
              conditions.push((c) => c.lt(field, value));
              break;
            case 'lte':
              conditions.push((c) => c.le(field, value));
              break;
            case 'like':
              conditions.push((c) => c.contains(field, value));
              break;
            case 'in':
              if (Array.isArray(value)) {
                conditions.push((c) => c.or(...value.map((v) => c.eq(field, v))));
              }
              break;
            default:
              logger.warn(`Unsupported operator: ${operator}`);
          }
        });
      } else {
        // Simple equality condition
        conditions.push((c) => c.eq(field, condition));
      }
    });

    // Combine all conditions with AND
    if (conditions.length === 0) {
      return undefined;
    } else if (conditions.length === 1) {
      return conditions[0];
    } else {
      return (c) => c.and(...conditions.map((condition) => condition(c)));
    }
  }

  /**
   * Insert a record using Amplify DataStore
   */
  public async insert<T extends DatabaseRecord>(table: string, data: T): Promise<T> {
    try {
      logger.debug(`Inserting into ${table}:`, data);
      const Model = this.getModelClass(table);

      // Create a new instance of the model with the data
      const item = new Model(data);
      const result = await DataStore.save(item);

      logger.debug(`Insert successful, ID: ${result.id}`);
      return result as T;
    } catch (error) {
      logger.error(`Error inserting into ${table}:`, error);
      throw error;
    }
  }

  /**
   * Update a record using Amplify DataStore
   */
  public async update<T extends DatabaseRecord>(
    table: string,
    id: string,
    data: Partial<T>
  ): Promise<T | null> {
    try {
      logger.debug(`Updating ${table} with ID ${id}:`, data);
      const Model = this.getModelClass(table);

      // Get the original record
      const original = await DataStore.query(Model, id);
      if (!original) {
        logger.warn(`Record not found for update: ${table} ID ${id}`);
        return null;
      }

      // Update the record using copyOf
      const result = await DataStore.save(
        Model.copyOf(original, (updated: any) => {
          Object.assign(updated, data);
        })
      );

      logger.debug(`Update successful for ${table} ID ${id}`);
      return result as T;
    } catch (error) {
      logger.error(`Error updating ${table} ID ${id}:`, error);
      throw error;
    }
  }

  /**
   * Get a record by ID using Amplify DataStore
   */
  public async getById<T extends DatabaseRecord>(table: string, id: string): Promise<T | null> {
    try {
      logger.debug(`Getting ${table} with ID ${id}`);
      const Model = this.getModelClass(table);

      const result = await DataStore.query(Model, id);

      if (!result) {
        logger.debug(`No record found for ${table} ID ${id}`);
        return null;
      }

      logger.debug(`Found record for ${table} ID ${id}`);
      return result as T;
    } catch (error) {
      logger.error(`Error getting ${table} ID ${id}:`, error);
      throw error;
    }
  }

  /**
   * Query records using Amplify DataStore
   */
  public async query<T extends DatabaseRecord>(table: string, query?: DatabaseQuery): Promise<T[]> {
    try {
      logger.debug(`Querying ${table}:`, query);
      const Model = this.getModelClass(table);

      // Start with a base query
      let predicate = undefined;

      // Apply filters if specified
      if (query?.where) {
        predicate = this.buildPredicates(query.where);
      }

      // Execute the query
      const queryResults =
        predicate !== undefined
          ? await DataStore.query(Model, predicate)
          : await DataStore.query(Model);

      // Ensure we have an array
      let results: any[] = Array.isArray(queryResults)
        ? queryResults
        : [queryResults].filter(Boolean);

      // Handle sorting
      if (query?.order) {
        const { field, direction } = query.order;
        results = results.sort((a: any, b: any) => {
          const directionMultiplier = direction === 'ASC' ? 1 : -1;
          return a[field] > b[field]
            ? directionMultiplier
            : a[field] < b[field]
              ? -directionMultiplier
              : 0;
        });
      }

      // Handle pagination
      if (query?.offset !== undefined && query?.limit !== undefined) {
        results = results.slice(query.offset, query.offset + query.limit);
      } else if (query?.limit !== undefined) {
        results = results.slice(0, query.limit);
      }

      logger.debug(`Query returned ${results.length} results for ${table}`);
      return results as T[];
    } catch (error) {
      logger.error(`Error querying ${table}:`, error);
      throw error;
    }
  }

  /**
   * Execute a custom query (limited support in Amplify)
   * This implementation attempts to support some common SQL operations by converting them to DataStore operations
   */
  public async execute<T>(sql: string, params?: any[]): Promise<T | T[] | null> {
    try {
      logger.debug(`Executing custom query: ${sql}, params:`, params);

      // This is a simplified SQL parser for demonstration purposes
      // In a real implementation, you would need a more robust solution

      // Example handling for count queries
      if (sql.toLowerCase().includes('select count(')) {
        const tableMatch = sql.match(/from\s+([a-zA-Z_]+)/i);
        if (tableMatch && tableMatch[1]) {
          const table = tableMatch[1];
          const Model = this.getModelClass(table);

          // If there's a WHERE clause, parse it
          let predicate: any = undefined;
          const whereMatch = sql.match(/where\s+(.*)/i);
          if (whereMatch && whereMatch[1] && params && params.length > 0) {
            // Very simplified where clause handling - would need proper SQL parsing
            // This is just an example of how you might convert SQL WHERE to DataStore predicates
            predicate = (c: any) => c.eq('id', params[0]);
          }

          const queryResults =
            predicate !== undefined
              ? await DataStore.query(Model, predicate)
              : await DataStore.query(Model);

          const results: any[] = Array.isArray(queryResults)
            ? queryResults
            : [queryResults].filter(Boolean);

          return { count: results.length } as T;
        }
      }

      // For other types of queries, we'd need to parse the SQL and transform to DataStore operations
      // This is complex and beyond the scope of this implementation

      logger.warn(`Unsupported SQL query: ${sql}`);
      return null;
    } catch (error) {
      logger.error(`Error executing custom query: ${sql}`, error);
      throw error;
    }
  }

  /**
   * Delete a record using Amplify DataStore
   * (This is an extension to the interface, not in the original implementation)
   */
  public async delete<T extends DatabaseRecord>(table: string, id: string): Promise<boolean> {
    try {
      logger.debug(`Deleting ${table} with ID ${id}`);
      const Model = this.getModelClass(table);

      const record = await DataStore.query(Model, id);
      if (!record) {
        logger.warn(`Record not found for deletion: ${table} ID ${id}`);
        return false;
      }

      await DataStore.delete(record);
      logger.debug(`Successfully deleted ${table} ID ${id}`);
      return true;
    } catch (error) {
      logger.error(`Error deleting ${table} ID ${id}:`, error);
      throw error;
    }
  }

  /**
   * Clear the DataStore (useful for testing)
   * (This is an extension to the interface, not in the original implementation)
   */
  public async clear(): Promise<void> {
    try {
      logger.warn('Clearing entire DataStore');
      await DataStore.clear();
      logger.info('DataStore cleared successfully');
    } catch (error) {
      logger.error('Error clearing DataStore:', error);
      throw error;
    }
  }
}
